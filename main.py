# -*- coding: utf-8 -*-
"""ENPM662_Final_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13tnGL-xiQR3n0wtGNjv1fOXieOKHlTaL

Running instructions: Please open the following file from a google colab from google drive, using colabartory application, on opening the file, Select Runtime>Run all from it context menu. If running from local system please change the cv2_imshow to cv2.imshow.
Also note that sometimes you might not be able to generate a output because an output might not be possible because of the random obstacle generator. So just rerun it at such scenarios. Also because of visualisation runtime is exceeding 10mins so I had to increase the step size, but for all the calculations and results in the report step size was 2.
"""

import numpy as np
import matplotlib.patches as patches
import random
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.path import Path
import cv2 as cv
import imageio
import time
import io
from google.colab.patches import cv2_imshow

class helper(object):
    """A utility class that provides various helper functions for the RRT* algorithm.

    Attributes:
        None

    Methods:
        boundary_samples(x_min, y_min, x_max, y_max): Samples a point uniformly within the given bounds.
        steer(eta,q_near, q_random): Steers from the nearest point to the random point within a maximum distance of eta.
        add_edges(a, b, ax, color = 'blue', width = 1): Draws an edge between two points on the plot.
        drawTree(mat, ax, color = 'black'): Draws the edges of the RRT* tree on the plot.
        add_shape(patch, ax): Draws a shape (obstacle or goal/start point) on the plot.
        draw_path(path, ax, color = 'green'): Draws the path on the plot.
        make_map(tree, ax): Draws the obstacles, start point, and goal point on the plot.
        save_image(fig, dpi= 180): Saves the plot as an image.
        generate_plot(tree,solution_path): Generates the plot with the RRT* tree and the solution path.
    """
    def boundary_samples(x_min, y_min, x_max, y_max):
        # Samples a point uniformly within the given bounds
        return np.array([np.random.uniform(x_min, x_max), np.random.uniform(y_min, y_max) ])

    def steer(eta,q_near, q_random):
        # Steers from the nearest point to the random point within a maximum distance of eta
        dist = np.linalg.norm(q_random - q_near)
        len_branch = min(eta,dist)
        q_dir = len_branch * (q_random - q_near)/dist
        return q_near+q_dir

    def add_edges(a, b, ax, color = 'blue', width = 0.5):
        # Draws an edge between two points on the plot
        path = Path([(a[0], a[1]), (b[0], b[1])], [Path.MOVETO, Path.LINETO])
        edge_patch = patches.PathPatch(path, facecolor='white', edgecolor= color, linewidth = width)
        ax.add_patch(edge_patch)

    def drawTree(mat, ax, color = 'black'):
        # Draws the edges of the RRT* tree on the plot
        for i in range(np.shape(mat)[0]):
            if mat[i, 3] != -1:
                parent_id = int(mat[i, 3])
                helper.add_edges(mat[i, 0:2], mat[parent_id, 0:2], ax, color)

    def add_shape(patch, ax):
        # Draws a shape (obstacle or goal/start point) on the plot
        ax.add_patch(patch)

    def draw_path(path, ax, color = 'green'):
        # Draws the path on the plot
        for i in range(np.shape(path)[0]-1):
            helper.add_edges(path[i], path[i+1], ax, color, 2)

    def make_map(tree, ax):
        # Draws the obstacles, start point, and goal point on the plot
        #draw obstacles
        for obs in tree.obstacles:
            helper.add_shape(obs.add_to_map('blue'), ax)
        #draw start and goal
        goal_node = patches.Circle((tree.goal_node[0], tree.goal_node[1]), 0.5, facecolor = 'orange' )
        start_node = patches.Circle((tree.start_node[0], tree.start_node[1]), 0.5, facecolor = 'pink' )
        helper.add_shape(goal_node, ax)
        helper.add_shape(start_node, ax)

    def save_image(fig, dpi= 180):
            # Saves the plot as an image
            buffer = io.BytesIO()
            fig.savefig(buffer, format = "png", dpi = dpi)
            buffer.seek(0)
            img_arr = np.frombuffer(buffer.getvalue(), dtype = np.uint8)
            buffer.close()
            img = cv.imdecode(img_arr,1)
            return img

    def generate_plot(tree,solution_path):
        # Generates the plot with the RRT* tree and the solution path
        fig,ax = plt.subplots()
        plt.ylim((-25,25))
        plt.xlim((-25,25))
        ax.set_aspect('equal',adjustable='box')
        pcur = tree.nodes[tree.pcurID,0:2]
        helper.add_shape(patches.Circle((pcur[0],pcur[1]),0.5,facecolor = 'red'),ax)
        helper.drawTree(tree.nodes,ax,'grey')
        helper.draw_path(solution_path,ax)
        helper.make_map(tree,ax)
        image = helper.save_image(fig)
        cv2_imshow(image)
        cv.waitKey(100)
        # Converting from BGR (OpenCV representation) to RGB (ImageIO representation)
        image = cv.cvtColor(image,cv.COLOR_BGR2RGB)
        plt.close()

        return image

class Obstacle(object):
    """
    Class representing an obstacle in the environment.
    """

    def __init__(self, type, params, mean_of_velocity,speed, goalLoc, covariance_of_velocity=np.eye(2)*0.02, borders=[-15,-15,15,15]):
        """
        Initialize the obstacle object.

        Parameters:
        - type: string type. Either 'rect' or 'circle'
        - parameters: for rect type: parameters = [x_min, y_min, width, height]
                      for circle type: parameters = [x_centre, y_centre, radius]
        - mean_of_velocity: mean of velocity multivariate Gaussian (updated at each t)
        - covariance_of_velocity: covariance of velocity multivariate Gaussian
        - speed: speed (limit) of obstacle
        - borders: list of environment borders [x_min, y_min, x_max, y_max]
        - goalLoc: goal location and radius for bounces [goal_x, goal_y, goal_r]
        """
        if not ((type == 'rect' and len(params) == 4) or (type == 'circle' and len(params) == 3)):
            raise ValueError
        self.type = type
        self.params = params
        if type == 'rect':
            self.pose = np.array([params[0], params[1]])
            self.width = params[2]
            self.height = params[3]
        if type == 'circle':
            self.pose = np.array([params[0], params[1]])
            self.radius = params[2]
        self.x_min = borders[0]
        self.y_min = borders[1]
        self.x_max = borders[2]
        self.y_max = borders[3]
        self.robot_r = 0.5
        self.goal_x = goalLoc[0]
        self.goal_y = goalLoc[1]
        self.goal_r = goalLoc[2]
        self.mean_of_velocity = mean_of_velocity
        self.covariance_of_velocity = covariance_of_velocity
        self.speed = speed

    def is_out_of_obstacle_space(self, x):
        """
        Check if the obstacle is in collision with a given position.

        Parameters:
        - x: position to check collision with

        Returns:
        - boolean indicating whether the obstacle is in collision
        """
        if len(x.shape) == 1:
            x = x.reshape(1, 2)

        if self.type == 'rect':
            return self.out_of_rectangle_spaces(x)
        else:
            return self.out_of_circles_spaces(x)

    def out_of_rectangle_spaces(self, x):
        """
        Check if the obstacle is in collision with a given position (rectangle type).

        Parameters:
        - x: position to check collision with

        Returns:
        - boolean indicating whether the obstacle is in collision
        """
        x_check = np.logical_and(x[:, 0] >= self.pose[0] - self.robot_r, x[:, 0] <= self.pose[0] + self.width + self.robot_r)
        y_check = np.logical_and(x[:, 1] >= self.pose[1] - self.robot_r, x[:, 1] <= self.pose[1] + self.height + self.robot_r)
        check = np.logical_and(x_check, y_check)
        obs_check = check.any()

        return np.logical_not(obs_check)

    def out_of_circles_spaces(self, x):
        """
        Check if the obstacle is in collision with a given position (circle type).

        Parameters:
        - x: position to check collision with

        Returns:
        - boolean indicating whether the obstacle is in collision
        """
        temp = x - self.pose
        dist = np.linalg.norm(temp, axis=1)
        check = dist <= self.radius + self.robot_r
        obs_check = check.any()

        return np.logical_not(obs_check)

    def add_to_map(self, color=[0.1, 0.2, 0.7]):
        """
        Return a patch object for plotting the obstacle.

        Parameters:
        - color: color of the patch

        Returns:
        - patch object for plotting
        """
        if self.type == 'rect':
            return patches.Rectangle((self.pose[0], self.pose[1]), self.width, self.height, ec='k', lw=1.5, facecolor=color)
        return patches.Circle((self.pose[0], self.pose[1]), self.radius, ec='k', lw=1.5, facecolor=color)

    def dynamic_obstacle(self, p_cur, dt):
        """
        Update the obstacle's dynamics and return the next timestep position.

        Parameters:
        - p_cur: current position of the obstacle
        - dt: timestep

        Returns:
        - next timestep position of the obstacle
        """
        velocity = np.random.multivariate_normal(self.mean_of_velocity, self.covariance_of_velocity)
        norm = np.linalg.norm(velocity)
        if not norm == 0:
            velocity = self.speed * (velocity / norm)
        self.mean_of_velocity, self.pose = self.bounce_off(p_cur[0], p_cur[1], velocity, dt)
        return self.pose

    def bounce_off(self, current_x, current_y, vel, dt):
        """
        Update the obstacle's velocity and position after a rebound.

        Parameters:
        - current_x: x-coordinate of the robot
        - current_y: y-coordinate of the robot
        - vel: velocity of the obstacle
        - dt: timestep

        Returns:
        - updated velocity and position of the obstacle
        """
        new = self.pose + vel * dt
        vel, rebound_border = self.can_border_rebound(new, vel)
        vel, rebound_goal = self.check_rebound_goal(new, vel)
        vel, rebound_robot = self.check_rebound_robot(current_x, current_y, new, vel)
        norm = np.linalg.norm(vel)
        if not norm == 0:
            vel = self.speed * (vel / norm)
        if (rebound_robot or rebound_goal) and rebound_border:
            vel *= vel * np.array([0, 0])
        if (rebound_border or rebound_goal or rebound_robot):
            new = self.pose + vel * dt
        return vel, new

    def can_border_rebound(self, new, vel):
        """
        Check if the obstacle rebounds from the environment borders.

        Parameters:
        - new: new position of the obstacle
        - vel: velocity of the obstacle

        Returns:
        - updated velocity and a boolean indicating whether a rebound occurred
        """
        rebound = False
        if self.type == 'rect':
            if new[0] + self.width > self.x_max:
                vel *= np.array([-1, 1])
                rebound = True
            elif new[0] < self.x_min:
                vel *= np.array([-1, 1])
                rebound = True
            if new[1] + self.height > self.y_max:
                vel *= np.array([1, -1])
                rebound = True
            elif new[1] < self.y_min:
                vel *= np.array([1, -1])
                rebound = True
        else:  # self.type=='circle'
            if new[0] > self.x_max - self.radius:
                vel *= np.array([-1, 1])
                rebound = True
            elif new[0] < self.x_min + self.radius:
                vel *= np.array([-1, 1])
                rebound = True
            if new[1] > self.y_max - self.radius:
                vel *= np.array([1, -1])
                rebound = True
            elif new[1] < self.y_min + self.radius:
                vel *= np.array([1, -1])
                rebound = True
        return vel, rebound

    def check_rebound_goal(self, new, vel):
        """
        Check if the obstacle rebounds from the goal.

        Parameters:
        - new: new position of the obstacle
        - vel: velocity of the obstacle

        Returns:
        - updated velocity and a boolean indicating whether a rebound occurred
        """
        rebound = False
        goal = np.array([self.goal_x, self.goal_y])
        if self.type == 'rect':
            center = new + np.array([self.width / 2, self.height / 2])
            diff = np.abs(center - goal)
            if (diff[0] < self.goal_r + self.width / 2) and (new[1] + self.height > self.goal_y and new[1] < self.goal_y):
                vel *= np.array([-1, 1])
                rebound = True
            elif (diff[1] < self.goal_r + self.height / 2) and (new[0] + self.width > self.goal_x and new[0] < self.goal_x):
                vel *= np.array([1, -1])
                rebound = True
            elif (np.linalg.norm(diff) < self.goal_r + np.linalg.norm([self.width / 2, self.height / 2])):
                vel *= np.array([-1, -1])
                rebound = True
        else:  # self.type=='circle'
            dist = np.linalg.norm(new - goal)
            if dist < (self.radius + self.goal_r):
                vel *= np.array([-1, -1])
                rebound = True
        return vel, rebound

    def check_rebound_robot(self, x, y, new, vel):
        """
        Check if the obstacle rebounds from the robot.

        Parameters:
        - x: x-coordinate of the robot
        - y: y-coordinate of the robot
        - new: new position of the obstacle
        - vel: velocity of the obstacle

        Returns:
        - updated velocity and a boolean indicating whether a rebound occurred
        """
        rebound = False
        robot = np.array([x, y])
        if self.type == 'rect':
            center = new + np.array([self.width / 2, self.height / 2])
            diff = np.abs(center - robot)
            if (diff[0] < self.robot_r + self.width / 2) and (new[1] + self.height > y and new[1] < y):
                vel *= np.array([-1, 1])
                rebound = True
            elif (diff[1] < self.robot_r + self.height / 2) and (new[0] + self.width > x and new[0] < x):
                vel *= np.array([1, -1])
                rebound = True
            elif (np.linalg.norm(diff) < self.robot_r + np.linalg.norm([self.width / 2, self.height / 2])):
                vel *= np.array([-1, -1])
                rebound = True
        else:  # self.type=='circle'
            dist = np.linalg.norm(new - robot)
            if dist < (self.radius + self.robot_r):
                vel *= np.array([-1, -1])
                rebound = True
        return vel, rebound

class RRT_star(object):
    """
    The RRT* path planning algorithm.
    """

    def __init__(self, start_node, goal_node, obstacles, x_min, y_min, x_max, y_max, max_node, res, eta, gamma, epsilon):
        """
        Initializes the RRT_star object.

        Args:
            start_node (tuple): The starting position of the tree.
            goal_node (tuple): The goal position of the tree.
            obstacles (list): A list of Obstacle objects.
            x_min (float): The minimum x-coordinate of the workspace.
            y_min (float): The minimum y-coordinate of the workspace.
            x_max (float): The maximum x-coordinate of the workspace.
            y_max (float): The maximum y-coordinate of the workspace.
            max_node (int, optional): The maximum number of nodes in the tree. Defaults to 1000.
            res (float, optional): The resolution for obstacle check along an edge. Defaults to 0.0001.
            eta (float, optional): The step size for steering towards a random sample. Defaults to 1.
            gamma (float, optional): The parameter for adjusting the radius of the hyperball. Defaults to 20.
            epsilon (float, optional): The tolerance for considering a node as near the goal. Defaults to 0.5.
        """
        self.nodes = np.array([start_node[0], start_node[1], 0, -1]).reshape(1, 4)
        self.obstacles = obstacles
        self.goal_ids = np.array([]).astype(int)
        self.update_q = []
        self.resolution = res
        self.left_out_tree = np.array([0, 0, 0, 0]).reshape(1, 4)
        self.seperate_id_path = np.array([])
        self.pcurID = 0
        self.x_min, self.y_min, self.x_max, self.y_max = x_min, y_min, x_max, y_max
        self.start_node = start_node
        self.goal_node = goal_node
        self.eta = eta
        # print("Eta: ", eta)
        self.gamma = gamma
        self.temp_tree = np.array([0, 0, 0, -1]).reshape(1, 4)
        self.epsilon = epsilon
        self.max_node = max_node

    def add_edge_to_tree(self, parent_id, child, cost):
        """
        Adds an edge to the tree.

        Args:
            parent_id (int): The ID of the parent node.
            child (tuple): The coordinates of the child node.
            cost (float): The cost to reach the child node from the parent node.

        Returns:
            int: The ID of the child node.
        """
        if parent_id > np.shape(self.nodes)[0] - 1 or parent_id < 0:
            print("Wrong parent ID.")
            return
        new_node = np.array([[child[0], child[1], float(cost), int(parent_id)]])
        self.nodes = np.append(self.nodes, new_node, axis=0)
        return len(self.nodes) - 1

    def find_nearest(self, sample):
        """
        Returns the nearest neighbor to the given sample from the nodes of the tree.

        Args:
            sample (tuple): The coordinates of the sample.

        Returns:
            tuple: The coordinates of the nearest neighbor and its ID.
        """
        temp = self.nodes[:, 0:2] - sample
        distance = np.linalg.norm(temp, axis=1)
        ID_nearest_node = np.argmin(distance)
        nearest_node = self.nodes[ID_nearest_node, 0:2]
        return nearest_node, ID_nearest_node

    def retrace_path(self, id_node, id_root=-1):
        """
        Returns the sequence of node IDs from the root node to the given node.

        Args:
            id_node (int): The ID of the node.
            id_root (int, optional): The ID of the root node. Defaults to -1.

        Returns:
            numpy.ndarray: The sequence of node IDs.
        """
        id_path = np.array([id_node])
        parent_id = int(self.nodes[id_node, 3])
        while parent_id != id_root:
            id_path = np.append(id_path, [parent_id])
            parent_id = int(self.nodes[parent_id, 3])
        if id_root != -1:
            id_path = np.append(id_path, [id_root])
        return np.flipud(id_path)

    def no_collision(self, node):
        """
        Checks if the given node is collision-free.

        Args:
            node (tuple): The coordinates of the node.

        Returns:
            bool: True if the node is collision-free, False otherwise.
        """
        for obs in self.obstacles:
            if not obs.is_out_of_obstacle_space(node):
                return False
        return True

    def branch_valid(self, x1, x2, len_branch):
        """
        Checks if a branch is feasible.

        Args:
            x1 (float): The x-coordinate of the start point of the branch.
            x2 (float): The x-coordinate of the end point of the branch.
            len_branch (float): The length of the branch.

        Returns:
            bool: True if the branch is feasible, False otherwise.
        """
        num_points = int(len_branch / self.resolution)
        x = np.linspace(x1, x2, num_points)
        return self.no_collision(x)

    def add_goal_id(self, goal_id):
        """
        Adds a goal ID to the list of near-goal node IDs.

        Args:
            goal_id (int): The ID of the goal node.
        """
        self.goal_ids = np.append(self.goal_ids, int(goal_id))

    def update_obstacle_space(self, dt):
        """
        Updates the positions of the obstacles.

        Args:
            dt (float): The time step for updating the positions.
        """
        for obst in self.obstacles:
            obst.dynamic_obstacle(self.nodes[self.pcurID], dt)

    def get_node_id(self, new_node, radius):
        """
        Returns the node IDs of the neighbors within the hyperball.

        Args:
            new_node (tuple): The coordinates of the new node.
            radius (float): The radius of the hyperball.

        Returns:
            tuple: The distances to the neighbors and their IDs.
        """
        temp = self.nodes[:, 0:2] - new_node
        dist = np.linalg.norm(temp, axis=1)
        dist = np.around(dist, decimals=4)
        neighbor_index = np.argwhere(dist <= radius)
        return dist, neighbor_index

    def min_cost_goal_id(self):
        """
        Returns the minimum cost and ID of the goal node.

        Returns:
            tuple: The minimum cost and ID of the goal node.
        """
        self.goal_ids = self.goal_ids.astype(int)
        c2g = self.nodes[self.goal_ids, 2]
        min_cost = np.argmin(c2g)
        return c2g[min_cost], self.goal_ids[min_cost]

    def select_parent(self, new_node, neighbor_index, distances):
        """
        Chooses the best parent for the new node.

        Args:
            new_node (tuple): The coordinates of the new node.
            neighbor_index (numpy.ndarray): The indices of the neighbors.
            distances (numpy.ndarray): The distances to the neighbors.

        Returns:
            tuple: The index of the best parent and the minimum cost.
        """
        nb_id = neighbor_index[0]
        parent_index = nb_id
        cost2branch = distances[nb_id]
        cost2nb = self.nodes[nb_id, 2]
        min_cost = cost2branch + cost2nb

        for nb_id in neighbor_index:
            cost2branch = distances[nb_id]
            cost2nb = self.nodes[nb_id, 2]
            cost = cost2branch + cost2nb
            if cost < min_cost and self.branch_valid(self.nodes[nb_id, 0:2], new_node, cost2branch):
                min_cost = cost
                parent_index = nb_id

        return parent_index, min_cost

    def rewire(self, new_id_node, neighbor_index, distances):
        """
        Rewires the tree nodes within the hyperball after a new node has been added to the tree.

        Args:
            new_id_node (int): The ID of the new node.
            neighbor_index (numpy.ndarray): The indices of the neighbors.
            distances (numpy.ndarray): The distances to the neighbors.
        """
        distance_to_neighbors = distances[neighbor_index]
        new_costs = distance_to_neighbors + self.nodes[new_id_node, 2]
        for i in range(neighbor_index.shape[0]):
            if new_costs[i] < self.nodes[neighbor_index[i], 2]:
                self.nodes[neighbor_index[i], 3] = self.nodes.shape[0] - 1
                self.nodes[neighbor_index[i], 2] = new_costs[i]
                children_indices = np.argwhere(self.nodes[:, 3] == neighbor_index[i])
                children_indices = list(children_indices)
                self.update_q.extend(children_indices)
                while len(self.update_q) != 0:
                    child_index = int(self.update_q.pop(0))
                    parent_index = int(self.nodes[child_index, 3])
                    dist = self.nodes[child_index, 0:2] - self.nodes[parent_index, 0:2]
                    self.nodes[child_index, 2] = self.nodes[parent_index, 2] + np.linalg.norm(dist)
                    next_indices = np.argwhere(self.nodes[:, 3] == child_index)
                    next_indices = list(next_indices)
                    self.update_q.extend(next_indices)

    def growth(self, exhaust=False, N=5000, FN=False):
        """
        Initializes the growth of the tree.

        Args:
            exhaust (bool, optional): If True, finish all N iterations before returning the solution path. Defaults to False.
            N (int, optional): The number of iterations for tree growth. Defaults to 5000.
            FN (bool, optional): If True, trims the tree when it exceeds the maximum number of nodes. Defaults to False.

        Returns:
            tuple: The solution path and its ID sequence.
        """

        is_goal = False
        num_iterations = 0
        max_iterations = 20

        def iterate(is_goal):
            if num_iterations >= max_iterations:
                return None, None, is_goal
            for i in range(N):
                q_random = helper.boundary_samples(self.x_min, self.y_min, self.x_max, self.y_max)
                q_near, q_near_id = self.find_nearest(q_random)
                qnew = helper.steer(self.eta, q_near, q_random)

                if self.branch_valid(q_near, qnew, np.linalg.norm(q_near - qnew)):
                    n = np.shape(self.nodes)[0]
                    radius = min(self.eta, self.gamma * np.sqrt(np.log(n) / n))
                    distances, NNids = self.get_node_id(qnew, radius)

                    naysID = np.append(np.array([q_near_id]), NNids)
                    qparent_id, qnewCost = self.select_parent(qnew, naysID, distances)
                    qnewID = self.add_edge_to_tree(int(qparent_id), qnew, qnewCost)

                    if np.linalg.norm(qnew - self.goal_node) < self.epsilon:
                        is_goal = True
                        self.add_goal_id(int(qnewID))

                    self.rewire(qnewID, naysID, distances)

                    if FN:
                        if np.shape(self.nodes)[0] > self.max_node:
                            self.forcedRemove(qnewID, self.goal_node, is_goal)

                if not exhaust:
                    if is_goal:
                        c2g, goal_id = self.min_cost_goal_id()
                        solution_id_path = self.retrace_path(goal_id)
                        return self.nodes[solution_id_path, 0:2], solution_id_path, is_goal
            if is_goal:
                c2g, goal_id = self.min_cost_goal_id()
                solution_id_path = self.retrace_path(goal_id)
                return self.nodes[solution_id_path, 0:2], solution_id_path, is_goal
            else:
                return -1, -1, is_goal

        while not is_goal:
            solution_path, solution_pathID, is_goal = iterate(is_goal)
            if solution_path is None:
                return None, None
        return solution_path, solution_pathID

    def collision_detection(self, solution_path):
        """
        Detects collision along the solution path.

        Args:
            solution_path (numpy.ndarray): The solution path.

        Returns:
            bool: True if a collision is detected, False otherwise.
        """
        num_points = 10000
        path_list = np.linspace(solution_path[0:-1], solution_path[1:], num_points)
        path_list = path_list.reshape(-1, 2)
        return np.logical_not(self.no_collision(path_list))

    def next_solution_node(self, solution_path, solution_path_id):
        """
        Updates the current node to the next node in the solution path.

        Args:
            solution_path (numpy.ndarray): The solution path.
            solution_pathID (numpy.ndarray): The ID sequence of the solution path.

        Returns:
            tuple: The shortened solution path, its ID sequence, and the length of the branch traversed.
        """
        self.pcurID = solution_path_id[1]
        dt = self.nodes[solution_path_id[1], 2] - self.nodes[solution_path_id[0], 2]
        return solution_path[1:], solution_path_id[1:], dt

    def reset(self, cost_inherited=True):
        """
        Resets the tree by clearing all nodes and seeding a new tree at the current node.

        Args:
            inheritCost (bool, optional): If True, inherit the cost of the current node. Defaults to True.
        """
        new_root = self.nodes[self.pcurID, 0:2]
        new_root_cost = self.nodes[self.pcurID, 2]
        self.nodes = np.array([new_root[0], new_root[1], 0, -1]).reshape(1, 4)
        if cost_inherited is True:
            self.nodes = np.array([new_root[0], new_root[1], new_root_cost, -1]).reshape(1, 4)
        self.goal_ids = np.array([]).astype(int)
        self.update_q = []
        self.left_out_tree = np.array([0, 0, 0, 0]).reshape(1, 4)

        self.seperate_id_path = np.array([])

start = [-22, -22]
goal = [22,22]
epsilon = 0.5 #near goal tolerance
goalLoc = [goal[0],goal[1],epsilon]
chaos = 0.05
xmin, ymin, xmax, ymax = -25,-25,25,25 #grid world borders
obstacles = []
for i in range(10):
    typ = random.choice(['rect', 'circle'])
    possible_speed=[0,2.5,5]
    speed = random.choice(possible_speed)

    if typ == 'rect':
        # Generate rectangle parameters: x, y, width, height
        x = random.randint(xmin,xmax)
        y = random.randint(ymin,ymax)
        width = random.randint(1, 5)
        height = random.randint(1, 5)
        params = [x, y, width, height]
    elif typ == 'circle':
        # Generate circle parameters: x, y, radius
        x = random.randint(xmin,xmax)
        y = random.randint(ymin,ymax)
        radius = random.randint(1, 3)
        params = [x, y, radius]

    # Create the obstacle
    obstacles.append(Obstacle(typ, params, [0, 0], speed, goalLoc=goalLoc))

maxNumNodes = np.inf #upper limit on tree size
eta = 3.5 #max branch length
gamma = 20.0 #param to set for radius of hyperball
resolution = 0.0001
goalFound = False
plot_and_save_gif = True

# Creating a list to store images at each frame
if plot_and_save_gif:
	images = []

# Start time
startTime = time.time()

#Initialize Tree and growth
tree = RRT_star(start,goal,obstacles,xmin,ymin,xmax,ymax,maxNumNodes,resolution,eta,gamma,epsilon)


#Get Solution Path
solution_path,solution_pathID = tree.growth(exhaust = True,FN = False)


# Visualizing the solution path
if plot_and_save_gif:
	im = helper.generate_plot(tree,solution_path)
	# Appending to list of images
	images.append(im)

# Get next node in solution path
solution_path,solution_pathID,dt = tree.next_solution_node(solution_path,solution_pathID)

# Visualizing the solution path
while np.linalg.norm(tree.nodes[tree.pcurID,0:2] - tree.goal_node) > tree.epsilon:
	if plot_and_save_gif:
		im = helper.generate_plot(tree,solution_path)
		# Appending to list of images
		images.append(im)

	# Obstacle Updates
	tree.update_obstacle_space(dt)

	# If solution_path breaks, reset tree and replan
	if tree.collision_detection(solution_path):
		print("Obstacle Collision Detected ! \nResetting Tree and Replanning ! \n")
		tree.reset(cost_inherited = True)
		solution_path,solution_pathID = tree.growth(exhaust = False,FN = False)

		if solution_path is None:
			print("No Solution Found ! \nExiting...")
			break


	solution_path,solution_pathID,dt = tree.next_solution_node(solution_path,solution_pathID)

print("Total Run Time: {} secs".format(time.time() - startTime))

if solution_path is not None:
	costToGoal, goalID = tree.min_cost_goal_id()
	print("Final Total Cost to Goal: {}".format(costToGoal))

if plot_and_save_gif:
	# Closing the display window
	cv.destroyAllWindows()

	# Saving the list of images as a gif
	print("The results are saved as a GIF to Animation_rrt_star.gif")
	imageio.mimsave('Animation_rrt_star.gif',images,duration = 0.5)